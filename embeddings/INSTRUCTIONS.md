# Manticore KNN Embeddings Library Development Instructions & Onboarding

> **Critical Reference**: Read this BEFORE making any changes. This document prevents common mistakes and ensures code quality for C++ integration.

## üéØ Core Philosophy

- **C++ First Design**: This is a Rust library optimized for C++ consumption via FFI
- **Zero-Copy Memory Management**: Reuse memory, avoid duplications, optimize for performance
- **Error Propagation**: Use `szError` pattern consistently - never return empty vectors on errors
- **Code Quality Standards**: Zero clippy warnings, no unused variables, no dead code
- **Memory Safety**: Proper cleanup of all allocated resources through FFI boundary

## üöÄ Quick Start Checklist

### Before Starting Any Task
1. **Context Discovery** (Execute in parallel):
   ```bash
   # Understand the codebase structure
   semantic_search(["embedding generation", "FFI interface", "error handling"])
   graphrag(operation="overview")
   view_signatures(files=["src/lib.rs", "src/ffi.rs", "src/model/mod.rs"])
   ```

2. **Code Analysis**:
   ```bash
   # Check for issues
   cargo clippy --lib -- -D warnings
   ast_grep(pattern="TODO|FIXME|XXX|HACK", context=2)
   ```

3. **Implementation Strategy**:
   - Identify if changes affect FFI boundary
   - Plan memory management approach
   - Consider C++ consumer impact

## üìÅ Project Structure Deep Dive

```
src/
‚îú‚îÄ‚îÄ lib.rs                    # Crate root, exports public API
‚îú‚îÄ‚îÄ ffi.rs                    # C FFI interface, GetLibFuncs() entry point
‚îú‚îÄ‚îÄ error.rs                  # LibError enum with 18 error variants
‚îú‚îÄ‚îÄ utils.rs                  # Utility functions (normalize, chunking, mean)
‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs               # Model trait and factory (create_model)
‚îÇ   ‚îú‚îÄ‚îÄ text_model_wrapper.rs # C FFI wrapper (CRITICAL for C++ integration)
‚îÇ   ‚îú‚îÄ‚îÄ openai.rs            # OpenAI API connector
‚îÇ   ‚îî‚îÄ‚îÄ local.rs             # Local model (Candle/HuggingFace)
‚îî‚îÄ‚îÄ *_test.rs                # Comprehensive test suites
```

### üîë Critical Files for C++ Integration

1. **`src/model/text_model_wrapper.rs`** - The heart of FFI
   - `load_model()` - Creates model instances
   - `make_vect_embeddings()` - Generates embeddings (FIXED: no empty vectors on error)
   - `free_model_result()` / `free_vec_result()` - Memory cleanup

2. **`manticoresearch_text_embeddings.h`** - Auto-generated C header
   - Generated by cbindgen from Rust code
   - Used by C++ consumers

3. **`src/ffi.rs`** - Library entry point
   - `GetLibFuncs()` - Returns function pointers to C++

## üõ†Ô∏è Common Task Patterns

### ‚ùå WRONG: Returning Empty Vectors on Error
```rust
// DON'T DO THIS - This was the bug we fixed
Err(e) => {
    let vec = FloatVec { ptr: ptr::null(), len: 0, cap: 0 };
    float_vec_list.push(vec);  // ‚ùå Empty vector pushed
    let c_error = std::ffi::CString::new(e.to_string()).unwrap();
    c_error.into_raw()
}
```

### ‚úÖ CORRECT: Proper Error Handling via szError Pattern
```rust
// DO THIS - Return only error, no empty vectors
Err(e) => {
    // Don't push empty vector - return error through szError pattern
    let c_error = std::ffi::CString::new(e.to_string()).unwrap();
    c_error.into_raw()
}
```

### ‚ùå WRONG: Memory Leaks in FFI
```rust
// DON'T DO THIS
pub extern "C" fn free_vec_result(result: FloatVecResult) {
    unsafe {
        let slice = std::slice::from_raw_parts(result.ptr, result.len); // ‚ùå No null check
        // ... cleanup without validation
    }
}
```

### ‚úÖ CORRECT: Safe Memory Management
```rust
// DO THIS - Always validate pointers
pub extern "C" fn free_vec_result(result: FloatVecResult) {
    unsafe {
        // Only process if we have valid data
        if !result.ptr.is_null() && result.len > 0 {
            let slice = std::slice::from_raw_parts(result.ptr, result.len);
            // ... safe cleanup
        }
        
        // Always clean up error string
        if !result.error.is_null() {
            let _ = std::ffi::CString::from_raw(result.error);
        }
    }
}
```

### ‚ùå WRONG: Hardcoded Configuration
```rust
// DON'T DO THIS
let max_tokens = 512;  // ‚ùå Hardcoded
let hidden_size = 768; // ‚ùå Hardcoded
```

### ‚úÖ CORRECT: Configuration-Driven Approach
```rust
// DO THIS - Use model configuration
let config: Value = serde_json::from_str(&contents)?;
let max_tokens = config["max_position_embeddings"].as_u64().unwrap() as usize;
let hidden_size = config["hidden_size"].as_u64().unwrap() as usize;
```

## üö´ Critical Anti-Patterns

### 1. Method/Function Proliferation
- **Problem**: Creating `validate_api_key_v2()`, `validate_api_key_new()`, etc.
- **Solution**: Improve existing functions, don't create variants

### 2. Hidden Variables and Dead Code
```rust
// ‚ùå DON'T DO THIS
let _unused_var = some_value;  // Silencing warnings
#[allow(dead_code)]           // Suppressing clippy
```
**Solution**: Fix the root cause, don't hide it

### 3. Memory Duplication
```rust
// ‚ùå DON'T DO THIS - Unnecessary cloning
let embeddings_copy = embeddings.clone();
std::mem::forget(embeddings);  // Original forgotten, copy used
```

### 4. Inconsistent Error Handling
```rust
// ‚ùå DON'T DO THIS - Mixed error patterns
return Err("String error".to_string());           // String
return Err(LibError::ModelLoadFailed);            // LibError
return Err(Box::new(std::io::Error::new(...)));   // Box<Error>
```
**Solution**: Use `LibError` consistently, convert at boundaries

## üîç Debugging & Investigation

### Common Issue Locations

| Issue Type | Primary Location | Investigation Tools |
|------------|------------------|-------------------|
| Memory leaks | `text_model_wrapper.rs` | `valgrind`, `cargo test` |
| Empty embeddings | `make_vect_embeddings()` | Unit tests, error logs |
| API failures | `openai.rs` | Network logs, API key validation |
| FFI crashes | All `extern "C"` functions | GDB, stack traces |
| Model loading | `create_model()` in `mod.rs` | File system checks |

### Tool Usage Patterns

```bash
# Find specific patterns
ast_grep(pattern="unwrap()", language="rust")  # Find potential panics
ast_grep(pattern="std::mem::forget($VAR)", language="rust")  # Memory management

# Semantic searches
semantic_search(["memory management", "FFI boundary", "error propagation"])
semantic_search(["embedding generation", "model loading", "cleanup"])

# Architecture queries
graphrag(operation="search", query="How does error handling work across FFI boundary?")
graphrag(operation="find-path", source_id="src/ffi.rs", target_id="src/model/openai.rs")
```

## üß™ Development Workflow

### Before Development
1. **Run full test suite**: `cargo test --lib`
2. **Check clippy**: `cargo clippy --lib -- -D warnings`
3. **Understand impact**: Will this affect C++ consumers?

### During Development
1. **Memory-first thinking**: How will C++ manage this memory?
2. **Error-first design**: What can go wrong? How to communicate it?
3. **Test-driven**: Write tests for both success and failure cases

### After Development
1. **Comprehensive testing**: All edge cases covered
2. **Memory validation**: No leaks, proper cleanup
3. **FFI verification**: C header regenerated if needed
4. **Performance check**: No unnecessary allocations

### Code Quality Gates
```bash
# Must pass before commit
cargo clippy --lib -- -D warnings  # Zero warnings
cargo test --lib                    # All tests pass
cargo build --release              # Release build works
```

## üß™ Testing Strategy

### Test Categories
1. **Unit Tests**: Individual function behavior
2. **Integration Tests**: Full workflow testing
3. **FFI Tests**: C interface validation
4. **Error Handling Tests**: All failure modes
5. **Memory Tests**: Cleanup verification

### OpenAI Testing
```rust
// Tests use real API key if available
let api_key = std::env::var("OPENAI_API_KEY").unwrap_or_else(|_| {
    println!("Skipping OpenAI test - OPENAI_API_KEY not set");
    return;
});
```

### Test Execution
```bash
# Run all tests
cargo test --lib

# Run specific test categories
cargo test utils_test::tests
cargo test error_test::tests
cargo test openai_test::tests  # Requires OPENAI_API_KEY

# Run with real OpenAI API
OPENAI_API_KEY=sk-your-key cargo test openai_test::tests
```

## üìö Quick Reference

### Essential Commands
```bash
# Development
cargo clippy --lib -- -D warnings    # Code quality check
cargo test --lib                      # Run all tests
cargo build --release                 # Release build

# FFI Development
cbindgen --config cbindgen.toml --crate manticore-knn-embeddings --output manticoresearch_text_embeddings.h

# Debugging
RUST_BACKTRACE=1 cargo test           # Stack traces
cargo test -- --nocapture             # See println! output
```

### Key Files for Common Tasks

| Task | Primary Files | Secondary Files |
|------|---------------|-----------------|
| Add new model | `src/model/mod.rs` | `src/model/` (new file) |
| Fix FFI issue | `src/model/text_model_wrapper.rs` | `src/ffi.rs` |
| Add error type | `src/error.rs` | All error handling |
| Memory optimization | `src/utils.rs` | `text_model_wrapper.rs` |
| API integration | `src/model/openai.rs` | `src/model/local.rs` |

### Configuration Hierarchy
1. **Environment Variables**: `OPENAI_API_KEY`, etc.
2. **Model Config Files**: JSON configuration from HuggingFace
3. **Compile-time Constants**: Version, default paths
4. **Runtime Parameters**: Passed through FFI

### Memory Management Rules
1. **Rust owns until FFI boundary**: Use `Box::into_raw()`
2. **C++ owns after boundary**: Must call `free_*` functions
3. **Error strings**: Always allocated, always freed
4. **Embedding vectors**: Forgotten in Rust, managed by C++
5. **Null pointer safety**: Always check before dereferencing

### Performance Optimization Guidelines
1. **Avoid cloning**: Use references where possible
2. **Batch operations**: Process multiple texts together
3. **Memory reuse**: Don't allocate unnecessarily
4. **Chunking strategy**: Balance memory vs. processing time
5. **Normalization**: In-place when possible (`&mut [f32]`)

---

## üÜò Emergency Procedures

### If Tests Are Failing
1. Check if it's an environment issue (missing `OPENAI_API_KEY`)
2. Run `cargo clippy` to catch code quality issues
3. Check memory safety in FFI functions
4. Verify error handling follows `szError` pattern

### If Memory Issues Occur
1. Check all `free_*` functions for null pointer validation
2. Verify `std::mem::forget()` usage is correct
3. Ensure C++ is calling cleanup functions
4. Use `valgrind` or similar tools for leak detection

### If FFI Crashes Occur
1. Check all `extern "C"` functions for safety
2. Verify pointer validity before dereferencing
3. Ensure proper error handling (no panics across FFI)
4. Check string encoding (UTF-8 vs C strings)

---

**Remember**: This library is the bridge between Rust's safety and C++'s performance. Every decision should consider both sides of this boundary.